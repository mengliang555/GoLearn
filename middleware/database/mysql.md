# MYSQL
- [What is mysql](https://www.mysql.com)

## [Index](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)
- Index Type
   - Primary key(聚集索引)
      - the value is unique and not null
      - all the index is based the primary key
   - Unique(唯一索引)
      - like Key but not allowed repeated value
   - Key
      - for all type
      - allowed repeated and empty value
   - Full-Text
      - just for test|char|varchar type
   - SpaTial(空间索引)
- Index Struct
  - B+树 

- Principle Of Build Index
  - 最左前缀匹配原则：mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
  - =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
  - 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例
  - 索引列不能参与计算，保持列“干净”
  - 尽量的扩展索引，不要新建索引
- [慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)
  - 步骤在链接中
## Database Transaction
- **事务特点**
  - 事务的原子性、一致性和持久性则是通过事务日志实现
  - 事务的隔离性是通过锁、MVCC等实现 （MySQL锁总结）
  - A(Atomicity)|原子性：
    - 事务的完整性。事务是执行不可分割的最小单位。所有操作要么全部成功或者全部失败
  - C(Consistency)|一致性：
    - 数据库的状态从一个一致性状态到达另一个一致性状态
  - D(Durability)|持久性：
    - 一旦事务提交，其操作的数据会持久化到数据库中。
  - I(Isolation)|隔离性：
    - 一个事务在完全完成之前，对外界不可见。
- **事务问题**
  - 更新丢失。多个事务同时更新原始数据，导致某个/些事务的更新丢失
    - 解决：事务提交前对其他事务不可见
  - 脏读。一个事务正在对记录进行修改，事务提交前，记录数据出于不一致状态。这时候，如果另一个事务修改相同位置数据，则会取到脏数据，并进行进一步处理，从而产生未提交数据的依赖关系
  - 不可重复读。一个事务在读取某些数据后的某个时间，再次读取相同数据后发现，读出的数据已经发生了改变、或某些记录已经被删除了。
  - 幻读。 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据。
  - **幻读和不可重复读的区别**
    - 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样
    - 幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样
- **隔离级别**：SQL标准定义了4类隔离级别
  - 读未提交(脏读)
    - 所有事务都可以看到其他事务未提交的部分
  - 提交读取(不可重复读)
    - 只能读取已经提交的事务的数据
  - 可重复读(幻读)
    - 同一事务的多个实例在并发读取数据时，会看到同样的数据行
  - Serializable(可串行化)
## Engine(InnoDB)
- 多版本并发控制(MVVC)
  - 实现
    - 每行记录后面保存两个隐藏的列来实现
    - 一个保存了行的创建时间，一个保存了行的过期时间（时间指的是系统版本号）
    - 每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较
  - 工作模式
    - Select
      - 创建版本号早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的
      - 删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除
    - Insert
      - InnoDB为新插入的每一行保存当前系统版本号作为行版本号
    - Delete
      - 删除的每一行保存当前系统版本号作为行删除标识
    - Update
      - InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识
  - 原理
    - 事务日志：
      - 使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中
      - 事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O
      - 事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。
    - redo-Log(重做日志)
      - 事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲(Log Buffer)中
      - 在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化
      - 当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘
      - 系统启动的时候，就已经为redo log分配了一块连续的存储空间,以顺序追加的方式记录Redo Log,通过顺序IO来改善性能
      - 所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起
    - undo-Log(未做日志)
      - undo log记录了数据在每个操作前的状态、
      - undo log主要为事务的回滚服务
    - 两阶段锁协议:
      - 分为加锁阶段和解锁阶段，所有的lock操作都在unlock操作之前
      - 死锁
        - 定义：不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程进入无限等待的状态
        - 解决方法
          - 设置 innodb_deadlock_detect = on，发起死锁检测，发现死锁之后主动回滚死锁链条中的某一个事务，让其他事务得以继续执行
          - 通过 innodb_lock_wait_timeout 来设置超时时间，InnoDB 中默认值是 50s，第一个被锁住的事务 A 等待超过 50s 才会超时退出，其他事务才能得以执行
## Best practice
- LIMIT 1 When Getting a Unique Row 
- Index the Search Fields 
- Avoid SELECT * 
- Index and Use Same Column Types for Joins 
- Almost Always Have an id Field  
- Use ENUM over VARCHAR 
- Use NOT NULL If You Can  
- 拒绝3B
  - 大sql（Big sql）
  - 大事务（Big transaction）
  - 大批量（Big batch）