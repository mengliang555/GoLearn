# Distributed Lock
- 使用原因：分布式环境下，多台机器上多个进程对同一个共享资源（数据、文件等）进行操作，如果不做互斥，可能导致资源出现异常
- 分布式锁的特性
  - 互斥性：在任意时刻，对于同一个锁，只有一个客户端能持有，从而保证一个共享资源同一时间只能被一个客户端操作
  - 安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其它客户端能加锁
  - 可用性：当提供锁服务的节点发生宕机等不可恢复性故障时，“热备” 节点能够接替故障的节点继续提供服务，并保证自身持有的数据与故障节点一致
  - 对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即客户端 A 不能把客户端 B 加的锁给解了

## ETCD 实现分布式锁
- **Lease机制**（安全性）
  - 即租约机制（TTL，Time To Live）
  - Etcd 可以为存储的 Key-Value 对设置租约，当租约到期，Key-Value 将失效删除
  - 同时也支持续约，通过客户端可以在租约到期之前续约，以避免 Key-Value 对过期失效
- **Revision机制**（公平锁）
  - 每个 Key 带有一个 Revision 号，每进行一次事务便加一，因此它是全局唯一的
  - 通过 Revision 的大小就可以知道写操作的顺序。在实现分布式锁时，多个客户端同时抢锁，根据 Revision 号大小依次获得锁，可以避免 “羊群效应” （也称“惊群效应”）
- **Prefix机制**
  - 即前缀机制，也称目录机制
  - 多个客户端同时写入，通过返回的Key-Value列表，各个客户端通过判断自己对应的Revision可以知道是否获取锁。从小到大依次拿锁
- **Watch机制**
  - 即监听机制，Watch 机制支持监听某个固定的 Key，也支持监听一个范围（前缀机制）
  - 当被监听的 Key 或范围发生变化，客户端将收到通知
  - 在实现分布式锁时，如果抢锁失败，可通过 Prefix 机制返回的 Key-Value 列表获得 Revision 比自己小且相差最小的 Key（称为 Pre-Key）
  - 对 Pre-Key 进行监听，因为只有它释放锁，自己才能获得锁，如果监听到 Pre-Key 的 DELETE 事件，则说明 Pre-Key 已经释放，自己已经持有锁。

### Etcd实现实践
```golang
  
```