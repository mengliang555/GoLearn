# [数据系统基础](https://github.com/Vonng/ddia/blob/master)

## [可靠性、可伸缩性和可维护性](https://github.com/Vonng/ddia/blob/master/part-i.md)

- 数据密集型：关键概念来自数据量、数据复杂性、以及数据的变更速度
- 可靠性（Reliability）
    - 系统在 困境（adversity，比如硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。请参阅 “可靠性”。
        - 故障（fault）: 造成错误的原因
        - 容错（fault-tolerant） 或 韧性（resilient）: 能预料并应对故障的系统特性
    - 鼓掌类型
        - 硬件故障
        - 软件错误
        - 人为错误
            - 以最小化犯错机会的方式设计系统
            - 将人们最容易犯错的地方与可能导致失效的地方 解耦
            - 在各个层次进行彻底的测试
            - 允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响
            - 配置详细和明确的监控，比如性能指标和错误率
- 可伸缩性（Scalability）
    - 有合理的办法应对系统的增长（数据量、流量、复杂性），是用来描述系统应对负载增长能力的术语
    - 负载参数（load parameters）：描述负载的数据。参数的最佳选择取决于系统架构。
    - 描述性能
        - 延迟和响应时间
        - 响应时间的高百分位点（也称为 尾部延迟，即 tail latencies
            - 百分位点通常用于 服务级别目标（SLO, service level objectives） 和 服务级别协议（SLA, service level agreements）
            - 排队延迟（queueing delay
    - 扩展方式
        - 纵向伸缩（垂直伸缩）：转向更强大的机器
        - 横向伸缩（水平伸缩）：将负载分布到多台小机器上
            - 跨多台机器分配负载也称为 “无共享（shared-nothing）” 架构
            - 弹性架构：在检测到负载增加时自动增加计算资源
    - 设计原则：
        - 围绕着 假设（assumption） 建立。
- 可维护性（Maintainability）
    - 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）
    - 考虑的三个设计原则
        - 可操作性（Operability
            - 便于运维团队保持系统平稳运行。
        - 简单性（Simplicity）
            - 从系统中消除尽可能多的 复杂度（complexity），使新工程师也能轻松理解系统（注意这和用户接口的简单性不一样）
                - 额外复杂度 定义为：由具体实现中涌现，而非（从用户视角看，系统所解决的）问题本身固有的复杂度
                - 抽象（abstraction ： 用于消除 额外复杂度 的最好工具之一
        - 可演化性（evolvability）
            - 使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为 可伸缩性（extensibility）、可修改性（modifiability） 或 可塑性（plasticity）

## [数据模型与查询语言](https://github.com/Vonng/ddia/blob/master/ch2.md)
- 关系模型与文档模型
  - 读模式：时候才知道数据格式-文档模型
  - 写模式：写入时候知道数据格式-关系模型
  - NO SQL
    - 文档数据库 的应用场景是：数据通常是自我包含的，而且文档之间的关系非常稀少
    - 图形数据库 用于相反的场景：任意事物都可能与任何事物相关联。

## [存储与检索](https://github.com/Vonng/ddia/blob/master/ch3.md)
- B树： B树保持按键排序的键值对
  - B 树将数据库分解成固定大小的块（block）或页面（page),传统上大小为 4KB（有时会更大）
  - 并且一次只能读取或写入一个页面
  - 每次需要两次写入
    - 一次写入预先写入日志（WAL write-ahead log)即重做日志(redo log)
    - 一次写入树页面本身（如果有分页还需要再写入一次）
- LSM树:(日志结构合并树)
  - 存在写放大情况
    - 反复压缩和合并 SSTables，日志结构索引也会多次重写数据
    - 
- 二者的比较：
  - 根据经验，通常 LSM 树的写入速度更快，而 B 树的读取速度更快【23】。 LSM 树上的读取通常比较慢，因为它们必须检查几种不同的数据结构和不同压缩（Compaction）层级的 SSTables。
  - LSM 树通常能够比 B 树支持更高的写入吞吐量
  - 志结构存储的缺点是压缩过程有时会干扰正在进行的读写操作
- 数据仓库
  - 事务处理（OLTP）  在线分析（OLAP）
  - 星型模式（也称为维度建模
  - 列式存储

## 编码与演化
- 当数据 格式（format） 或 模式（schema） 发生变化时，通常需要对应用程序代码进行相应的更改
  - 新旧版本的代码，以及新旧数据格式可能会在系统中同时共处。系统想要继续顺利运行，就需要保持 双向兼容性
    - 向后兼容 (backward compatibility)
      - 新代码可以读旧数据。
    - 向前兼容 (forward compatibility)
      - 旧代码可以读新数据。
- 编码和解码
  -  从内存中表示到字节序列的转换称为 编码（Encoding）也称为 序列化（serialization） 或 编组（marshalling））
  -  反过来称为 解码（Decoding）2（解析（Parsing），反序列化（deserialization），反编组 (unmarshalling））
-  服务中的数据流：REST与RPC
   -  REST 不是一个协议，而是一个基于 HTTP 原则的设计哲学
      -  它强调简单的数据格式
      -  使用 URL 来标识资源
      -  使用 HTTP 功能进行缓存控制，身份验证和内容类型协商
   -  远程过程调用（RPC）的问题
      -  本地函数调用是可预测的 。网络请求是不可预知的
      -  需要考虑网络因素
      -  考虑请求重试，服务幂等
      -  大数据量传输